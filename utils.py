import numpy as np
import torch
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

import json
from collections import OrderedDict
from typing import List

import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator


def get_parameters(net) -> List[np.ndarray]:
    return [val.cpu().numpy() for _, val in net.state_dict().items()]

def set_parameters(net, parameters: List[np.ndarray]):
    params_dict = zip(net.state_dict().keys(), parameters)
    state_dict = OrderedDict({k: torch.Tensor(v) for k, v in params_dict})
    net.load_state_dict(state_dict, strict=True)

def train(net, train_loader, epochs, DEVICE):
  """ Train the network on the training set. """
  criterion = torch.nn.CrossEntropyLoss()
  optimizer = torch.optim.SGD(net.parameters(), lr = 0.001, momentum = 0.9)

  avg_cost = 0.0

  for i in range(epochs):
    avg_cost = 0.0
    total_batch = len(train_loader)

    for X, y in train_loader:
      net.train()
      X, y = X.to(DEVICE), y.to(DEVICE)
      optimizer.zero_grad()
      loss = criterion(net(X), y.argmax(-1))
      loss.backward()
      optimizer.step()

      avg_cost += loss.item() / total_batch

  return avg_cost


def test(net, test_loader, DEVICE):
  """ Evaluate the network on the entire test set. """
  criterion = torch.nn.CrossEntropyLoss()
  correct, total, loss = 0, 0, 0.0

  pred = torch.Tensor([])
  target = torch.Tensor([])
  net.eval()

  with torch.no_grad():
    for X, y in test_loader:
        net.eval()
        X, y = X.to(DEVICE), y.to(DEVICE)
        outputs = net(X)
        _, predicted = torch.max(outputs.data, 1)
        loss += criterion(outputs, y.argmax(-1)).item()
        correct += (predicted == y.argmax(-1)).sum().item()
        pred = torch.cat([pred, predicted], dim=0)
        target = torch.cat([target, y.argmax(-1)], dim=0)
        total += y.size(0)

    loss /= len(test_loader.dataset)
    accuracy = correct / total

    return loss, accuracy, pred, target



def plot_metrics(RESULT_PATH):
    with open(RESULT_PATH) as result_file:
      results = json.load(result_file)

    for metric in ["loss", "accuracy", "f1_score"]:
      fig, ax = plt.subplots()

      for strategy, result in results.items():
        xs = [item[0] for item in result[metric]]
        ys = [item[1] for item in result[metric]]
        ax.plot(xs, ys, label=strategy)

      ax.legend()
      ax.xaxis.set_major_locator(MaxNLocator(integer=True))

      plt.xlabel("Round")
      plt.ylabel(metric.capitalize())
      plt.title(f"Evaluation about {metric}")
      plt.savefig(f"./results/Evaluate_{metric}.png")
      plt.clf()


def plot_metrics_2(RESULT_PATH):


  #strategies = ['FedAvg', 'FedAvgM', 'QffedAvg', 'FaultTolerantFedAvg', 'FedOpt', 'FedAdam', 'FedAdagrad', 'FedYogi']
  strategies = ['FedAvg', 'FedAvgM', 'FaultTolerantFedAvg', 'FedOpt', 'FedAdam', 'FedAdagrad', 'FedYogi']
  metrics = ['loss', 'accuracy', 'f1_score']

  with open(RESULT_PATH) as result_file:
    results = json.load(result_file)
  df_result = pd.DataFrame(
    columns=metrics
  )


  for strategy, result in results.items():
    if strategy not in strategies:
      continue

    df_strategy = pd.DataFrame(
      columns=result.keys()
    )
    for metric in result.keys():
      df_strategy[metric] = [info[1] for info in result[metric]]
    
    df_strategy['round'] = [r for r in range(len(df_strategy))]
    df_strategy['strategy'] = strategy

    df_result = pd.concat([df_result, df_strategy], axis=0)
  
  for metric in metrics:

    fig = px.line(
      df_result, 
      x='round', 
      y=metric, 
      color='strategy',
      labels = dict(
        round="<b>Round</b>", 
        f1_score="<b>F1-Score</b>", 
        accuracy="<b>Accuracy</b>", 
        loss="<b>Loss</b>", 
        strategy=" "),
    )

    fig.update_layout(
      plot_bgcolor="white",
      font=dict(
        size=12
      )
    )

    fig.update_xaxes(
      linecolor = "black",
      linewidth = 2,
      mirror = True,
    )

    fig.update_yaxes(
      linecolor = "black",
      linewidth = 2,
      mirror = True,
    )

    fig.write_image(f"./results/Evaluate_{metric}.png")
  


def plot_subplots(RESULT_PATH):


  #strategies = ['FedAvg', 'FedAvgM', 'QffedAvg', 'FaultTolerantFedAvg', 'FedOpt', 'FedAdam', 'FedAdagrad', 'FedYogi']
  strategies = ['FedAvg', 'FedAvgM', 'FaultTolerantFedAvg', 'FedOpt', 'FedAdam', 'FedAdagrad', 'FedYogi']
  #metrics = ['loss', 'accuracy', 'f1_score']
  metrics = ['loss', 'f1_score']
  colors = {
    'FedAvg': 'black',
    'FedAvgM': 'red', 
    'FaultTolerantFedAvg': 'magenta', 
    'FedOpt': 'purple', 
    'FedAdam': 'green', 
    'FedAdagrad': 'blue', 
    'FedYogi': 'orange'
  }

  with open(RESULT_PATH) as result_file:
    results = json.load(result_file)
  df_result = pd.DataFrame(
    columns=metrics
  )

  fig = make_subplots(rows=1, cols=len(metrics), horizontal_spacing=0.1)

  for strategy, result in results.items():
    if strategy not in strategies:
      continue

    df_strategy = pd.DataFrame(
      columns=result.keys()
    )
    for i, metric in enumerate(metrics):
      df_strategy[metric] = [info[1] for info in result[metric]]

      # xaxis = go.XAxis(title='Round', titlefont=go.Font(color='SteelBlue'))
      # yaxis = go.YAxis(title=f'{metric}', titlefont=go.Font(color='SteelBlue'))

      fig.add_trace(
        go.Scatter(
          x=[r for r in range(len(df_strategy))],
          y=[info[1] for info in result[metric]],
          mode='lines',
          name=f'{strategy}',
          marker_color=colors[strategy],
          showlegend=True if i == 0 else False,
        ),
        row=1, col=1+i
      )   
      # fig['layout'][f'xaxis']['title'] = 'Round'
      # fig['layout'][f'yaxis']['title'] = metric
      fig.update_xaxes(
        title='Round',
        tickfont = dict(
          size=20,
        ),
        row=1, col=1+i
      )
      fig.update_yaxes(
        title=f'{metric}',
        tickfont = dict(
          size=20,
        ),
        row=1, col=1+i
      )



    df_strategy['round'] = [r for r in range(len(df_strategy))]
    df_strategy['strategy'] = strategy

    df_result = pd.concat([df_result, df_strategy], axis=0)
  


    # fig = px.line(
    #   df_result, 
    #   x='round', 
    #   y=metric, 
    #   color='strategy',
    #   labels = dict(
    #     round="<b>Round</b>", 
    #     f1_score="<b>F1-Score</b>", 
    #     accuracy="<b>Accuracy</b>", 
    #     loss="<b>Loss</b>", 
    #     strategy=" "),
    # )

    fig.update_layout(
      plot_bgcolor="white",
      font=dict(
        size=20
      ),
      width=2100,
      height=600,

    )

    fig.update_xaxes(
      linecolor = "black",
      linewidth = 2,
      mirror = True,
    )

    fig.update_yaxes(
      linecolor = "black",
      linewidth = 2,
      mirror = True,
    )

    fig.write_image(f"./results/Evaluate_combined.png")
  

if __name__ == "__main__":
  #plot_metrics("./results/result.json")
  #plot_metrics_2("./results/result.json")
  plot_subplots("./results/result.json")