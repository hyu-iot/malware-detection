import torch
import flwr as fl

from collections import OrderedDict
from typing import List, Dict, Tuple, Optional
import json

from client import FLClient
from client_manager import ClientManager
from model import Net, LSTMNet
from utils import get_parameters, set_parameters, train, test, plot_metrics


DEVICE = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
EPOCH = 2
NUM_CLIENTS = 10

learning_rate = 0.01
global_timestamp = 1
cm_list = []

config = {
    "type": "dnn",
    "period": 600,
    "train_ratio": 0.7,
    "batch_size": 20,
    "shuffle": False,
    "seq_len": 10,
    "random_seed": 1234,
}

for i in range(20):
  cm = ClientManager(config)
  trainloaders, testloaders = cm.build_dataloader(DATA_PATH=f"./dataset/iot23_{i}.npy")
  cm_list.append(cm)


def client_fn(cid: str) -> FLClient:
  """ Create a Flower client representing a single organization. """
  
  # Get ClientManager
  cm = cm_list[int(cid)]
  
  # Load model
  net = Net().to(DEVICE)

  # Load data
  trainloader, testloader = cm.get_dataloader(global_timestamp)

  # Create a single Flower client representing a single organization
  return FLClient(net, trainloader, testloader, DEVICE)



# Server-side
fedavg_losses, fedavgM_losses, qfedavg_losses = [], [], []
fedavg_accuracies, fedavgM_accuracies, fedavg_accuracies = [], [], []

# The `evaluate` function will be by Flower called after every round
def evaluate(
    server_round: int, parameters: fl.common.NDArrays, config: Dict[str, fl.common.Scalar]
) -> Optional[Tuple[float, Dict[str, fl.common.Scalar]]]:
    global global_timestamp

    net = Net()
    valloader, _ = cm_list[0].get_dataloader(0)
    set_parameters(net, parameters)  # Update model with the latest parameters
    loss, accuracy, _, _ = test(net, valloader, DEVICE)
    
    global_timestamp += 1

    fedavg_losses.append(loss)
    fedavg_accuracies.append(accuracy)

    print(f"Server-side evaluation loss {loss} / accuracy {accuracy}")
    return loss, {"accuracy": accuracy}



def fit_config (global_round: int):
    #Return training configuration dict for each round
    config = {
        "global_round": global_round,
    }
    return config

def evaluate_config (global_round: int):
    config = {
        "global_round": global_round,
    }
    return config



# ## Define strategies
fedavg = fl.server.strategy.FedAvg(
    fraction_fit=1.0,             # Sample 100% of available clients for training
    fraction_evaluate=0.5,        # Sample 50% of available clients for evaluation
    min_fit_clients=10,           # Never sample less than 10 clients for training
    min_evaluate_clients=5,       # Never sample less than 5 clients for evaluation
    min_available_clients=10,     # Wait until all 10 clients are available
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

fedavgM = fl.server.strategy.FedAvgM(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

qfedavg = fl.server.strategy.QFedAvg(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

ftfedavg = fl.server.strategy.FaultTolerantFedAvg(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

fedopt = fl.server.strategy.FedOpt(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

fedadagrad = fl.server.strategy.FedAdagrad(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

fedadam = fl.server.strategy.FedAdam(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)

fedyogi = fl.server.strategy.FedYogi(
    fraction_fit=1.0,             
    fraction_evaluate=0.5,        
    min_fit_clients=10,           
    min_evaluate_clients=5,       
    min_available_clients=10,
    initial_parameters=fl.common.ndarrays_to_parameters(get_parameters(Net())),
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)


# ## Starting the training

# Create FedAvg strategy
strategy = fl.server.strategy.FedAvg(
    fraction_fit=1.0,             # Sample 100% of available clients for training
    fraction_evaluate=0.5,        # Sample 50% of available clients for evaluation
    min_fit_clients=10,           # Never sample less than 10 clients for training
    min_evaluate_clients=5,       # Never sample less than 5 clients for evaluation
    min_available_clients=10,     # Wait until all 10 clients are available
    evaluate_fn=evaluate,
    on_fit_config_fn=fit_config,
    on_evaluate_config_fn=evaluate_config,
)



results = {}
strategies = [fedavg, fedavgM, qfedavg, ftfedavg, fedopt, fedadam, fedadagrad, fedyogi]

# Start simulation
for strategy in strategies:
    global_timestamp = 1

    net = Net().to(DEVICE)
    hist = fl.simulation.start_simulation(
        client_fn=client_fn,
        num_clients=NUM_CLIENTS,
        config=fl.server.ServerConfig(num_rounds=20),
        strategy=strategy
    )
    results[repr(strategy).split('(')[0]] = hist.metrics_centralized


with open(f"./results/result.json", mode="w") as result_file:
    json.dump(results, result_file)

plot_metrics("./results/result.json")
