import numpy as np
import torch
from torch.utils.data import TensorDataset, DataLoader

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

class ClientManager():

  def __init__(self, config):
    self.config = config
    self.data_all = None
    self.rounds = []

  def round(self, idx):
    if idx >= len(self.rounds):
      return None
    else:
      return self.rounds[idx]
    

  def build(self, DATA_PATH, config=None):
    if config is not None:
      self.config = config
    
    self.data_all = np.load(DATA_PATH, allow_pickle=True)
    
    data_split, lengths = self.__split_timestamp(self.data_all, self.config["period"])
    for round_data in data_split:
      self.rounds.append(self.__build_round(round_data))
    

  def __build_round(self, round_data):
    if len(round_data) < 2:
      return Round(round_data, None, None, None, None)

    scaler = MinMaxScaler()
    scaler.fit(round_data[:, 1:])
    round_data[:, 1:] = scaler.transform(round_data[:, 1:])

    if self.config['type'].lower() == 'lstm':
      trainset, testset = self.__build_lstm_dataset(round_data)
    elif self.config['type'].lower() == 'dnn':
      trainset, testset = self.__build_nn_dataset(round_data)
    
    trainloader = DataLoader(
        trainset, 
        batch_size=self.config['batch_size'],
        shuffle=self.config['shuffle']
    )
    testloader = DataLoader(
        testset, 
        batch_size=self.config['batch_size'],
        shuffle=self.config['shuffle']
    )
    return Round(round_data, trainset, testset, trainloader, testloader)
    

  def __build_lstm_dataset(self, round_data):

    train_len = int(self.config["train_ratio"] * len(round_data))      
    test_len = len(round_data) - train_len      
    
    data_train, data_test = round_data[:train_len], round_data[train_len:]
    X_train, y_train = self.__manipulate_sequence(data_train, self.config["seq_len"])
    X_test, y_test = self.__manipulate_sequence(data_test, self.config["seq_len"])

    X_train, y_train = X_train.astype(np.float32), y_train.astype(np.float32)
    X_train, y_train = torch.from_numpy(X_train), torch.from_numpy(y_train)

    X_test, y_test = X_test.astype(np.float32), y_test.astype(np.float32)
    X_test, y_test = torch.from_numpy(X_test), torch.from_numpy(y_test)

    return TensorDataset(X_train, y_train), TensorDataset(X_test, y_test)


  def __build_nn_dataset(self, round_data):

    X_train, X_test, y_train, y_test = train_test_split(
      round_data[:, :-12], 
      round_data[:, -12:],
      train_size=self.config["train_ratio"],
      random_state=self.config["random_seed"]
    )

    X_train, y_train = X_train.astype(np.float32), y_train.astype(np.float32)
    X_train, y_train = torch.from_numpy(X_train), torch.from_numpy(y_train)

    X_test, y_test = X_test.astype(np.float32), y_test.astype(np.float32)
    X_test, y_test = torch.from_numpy(X_test), torch.from_numpy(y_test)

    return TensorDataset(X_train, y_train), TensorDataset(X_test, y_test)


  def __split_timestamp(self, data, period):
    data_split, lengths = [], []
    start_time, end_time = data[0][0], data[-1][0]
    num_round = int(np.ceil((end_time-start_time) / float(period)))

    for r in range(num_round):
      data_round = np.array([data[i][1:] for i in range(data.shape[0]) if data[i][0] >= start_time + r*period and data[i][0] <= start_time + (r+1)*period])
      data_split.append(data_round)
      lengths.append(len(data_round))
      
    return data_split, lengths

  def __manipulate_sequence(self, data, seq_len):
    X = []
    y = []
    for i in range(0, len(data)-seq_len):
      X.append(data[i:i+seq_len, :-12])
      y.append(data[i+seq_len, -12:])
    
    return np.array(X), np.array(y)


class Round():
  
  def __init__(self, data, trainset, testset, trainloader, testloader):
    self.data = data
    self.trainset = trainset
    self.testset = testset
    self.trainloader = trainloader
    self.testloader = testloader

  def get_dataset(self):
    return self.trainset, self.testset

  def get_dataloader(self):
    return self.trainloader, self.testloader
